###################################
# spray-can Reference Config File #
###################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

spray.can {

  server {
    # The value of the `Server` header to produce.
    # Set to the empty string to disable rendering of the server header.
    server-header = spray-can/${spray.version}

    # Enables/disables SSL encryption.
    # If enabled the server uses the implicit `ServerSSLEngineProvider` member
    # of the `Bind` command to create `SSLEngine` instances for the underlying
    # IO connection.
    ssl-encryption = off

    # The maximum number of requests that are accepted (and dispatched to
    # the application) on one single connection before the first request
    # has to be completed.
    # Incoming requests that would cause the pipelining limit to be exceeded
    # are not read from the connections socket so as to build up "back-pressure"
    # to the client via TCP flow control.
    # A setting of 1 disables HTTP pipelining, since only one request per
    # connection can be "open" (i.e. being processed by the application) at any
    # time. Set to higher values to enable HTTP pipelining.
    # Set to 'disabled' for completely disabling pipelining limits
    # (not recommended on public-facing servers due to risk of DoS attacks).
    # This value must be > 0 and <= 128.
    pipelining-limit = 1

    # The time after which an idle connection will be automatically closed.
    # Set to `infinite` to completely disable idle connection timeouts.
    idle-timeout = 60 s

    # If a request hasn't been responded to after the time period set here
    # a `spray.http.Timedout` message will be sent to the timeout handler.
    # Set to `infinite` to completely disable request timeouts.
    request-timeout = 20 s

    # After a `Timedout` message has been sent to the timeout handler and the
    # request still hasn't been completed after the time period set here
    # the server will complete the request itself with an error response.
    # Set to `infinite` to disable timeout timeouts.
    timeout-timeout = 2 s

    # The period during which a service must respond to a `ChunkedRequestStart` message
    # with a `RegisterChunkHandler` message. During the registration period reading from
    # the network is suspended. It is still possible that some chunks have already been
    # received which will be buffered until the registration is received or the timeout is
    # triggered. If the timeout is triggered the connection is immediately aborted.
    chunkhandler-registration-timeout = 500 ms

    # The path of the actor to send `spray.http.Timedout` messages to.
    # If empty all `Timedout` messages will go to the "regular" request
    # handling actor.
    timeout-handler = ""

    # The "granularity" of timeout checking for both idle connections timeouts
    # as well as request timeouts, should rarely be needed to modify.
    # If set to `infinite` request and connection timeout checking is disabled.
    reaping-cycle = 250 ms

    # Enables/disables support for statistics collection and querying.
    # Even though stats keeping overhead is small,
    # for maximum performance switch off when not needed.
    stats-support = on

    # Enables/disables the addition of a `Remote-Address` header
    # holding the clients (remote) IP address.
    remote-address-header = off

    # Enables/disables the addition of a `Raw-Request-URI` header holding the
    # original raw request URI as the client has sent it.
    raw-request-uri-header = off

    # Enables/disables automatic handling of HEAD requests.
    # If this setting is enabled the server dispatches HEAD requests as GET
    # requests to the application and automatically strips off all message
    # bodies from outgoing responses.
    # Note that, even when this setting is off the server will never send
    # out message bodies on responses to HEAD requests.
    transparent-head-requests = on

    # Enables/disables an alternative response streaming mode that doesn't
    # use `Transfer-Encoding: chunked` but rather renders the individual
    # MessageChunks coming in from the application as parts of the original
    # response entity.
    # Enabling this mode causes all connections to be closed after a streaming
    # response has been finished since there is no other way to signal the
    # response end to the client.
    # Note that chunkless-streaming is implicitly enabled when streaming
    # responses to HTTP/1.0 clients (since they don't support
    # `Transfer-Encoding: chunked`)
    chunkless-streaming = off

    # Enables/disables the returning of more detailed error messages to
    # the client in the error response.
    # Should be disabled for browser-facing APIs due to the risk of XSS attacks
    # and (probably) enabled for internal or non-browser APIs.
    # Note that spray will always produce log messages containing the full
    # error details.
    verbose-error-messages = off

    # If this setting is non-zero the HTTP server automatically aggregates
    # incoming request chunks into full HttpRequests before dispatching them to
    # the application. If the size of the aggregated requests surpasses the
    # specified limit the server responds with a `413 Request Entity Too Large`
    # error response before closing the connection.
    # Set to zero to disable automatic request chunk aggregation and have
    # ChunkedRequestStart, MessageChunk and ChunkedMessageEnd messages be
    # dispatched to the handler.
    request-chunk-aggregation-limit = 1m

    # The initial size if the buffer to render the response headers in.
    # Can be used for fine-tuning response rendering performance but probably
    # doesn't have to be fiddled with in most applications.
    response-header-size-hint = 512

    # For HTTPS connections this setting specified the maximum number of
    # bytes that are encrypted in one go. Large responses are broken down in
    # chunks of this size so as to already begin sending before the response has
    # been encrypted entirely.
    max-encryption-chunk-size = 1m

    # The time period within which the TCP binding process must be completed.
    # Set to `infinite` to disable.
    bind-timeout = 1s

    # The time period within which the TCP unbinding process must be completed.
    # Set to `infinite` to disable.
    unbind-timeout = 1s

    # The time period within which a connection handler must have been
    # registered after the bind handler has received a `Connected` event.
    # Set to `infinite` to disable.
    registration-timeout = 1s

    # The time after which a connection is aborted (RST) after a parsing error
    # occurred. The timeout prevents a connection which is already known to be
    # erroneous from receiving evermore data even if all of the data will be ignored.
    # However, in case of a connection abortion the client usually doesn't properly
    # receive the error response. This timeout is a trade-off which allows the client
    # some time to finish its request and receive a proper error response before the
    # connection is forcibly closed to free resources.
    parsing-error-abort-timeout = 2s

    # If this setting is empty the server only accepts requests that carry a
    # non-empty `Host` header. Otherwise it responds with `400 Bad Request`.
    # Set to a non-empty value to be used in lieu of a missing or empty `Host`
    # header to make the server accept such requests.
    # Note that the server will never accept HTTP/1.1 request without a `Host`
    # header, i.e. this setting only affects HTTP/1.1 requests with an empty
    # `Host` header as well as HTTP/1.0 requests.
    # Examples: `www.spray.io` or `example.com:8080`
    default-host-header = ""

    # Enables/disables automatic back-pressure handling by write buffering and
    # receive throttling
    automatic-back-pressure-handling = on

    back-pressure {
        # The reciprocal rate of requested Acks per NoAcks. E.g. the default value
        # '10' means that every 10th write request is acknowledged. This affects the
        # number of writes each connection has to buffer even in absence of back-pressure.
        noack-rate = 10

        # The lower limit the write queue size has to shrink to before reads are resumed.
        # Use 'infinite' to disable the low-watermark so that reading is resumed instantly
        # after the next successful write.
        reading-low-watermark = infinite
    }

    # Enables more verbose DEBUG logging for debugging SSL related issues.
    ssl-tracing = off

    # Modify to tweak parsing settings on the server-side only.
    parsing = ${spray.can.parsing}
  }

  client {
    # The default value of the `User-Agent` header to produce if no
    # explicit `User-Agent`-header was included in a request.
    # If this value is the empty string and no header was included in
    # the request, no `User-Agent` header will be rendered at all.
    user-agent-header = spray-can/${spray.version}

    # The time after which an idle connection will be automatically closed.
    # Set to `infinite` to completely disable idle timeouts.
    idle-timeout = 60 s

    # The max time period that a client connection will be waiting for a response
    # before triggering a request timeout. The timer for this logic is not started
    # until the connection is actually in a state to receive the response, which
    # may be quite some time after the request has been received from the
    # application!
    # There are two main reasons to delay the start of the request timeout timer:
    # 1. On the host-level API with pipelining disabled:
    #    If the request cannot be sent immediately because all connections are
    #    currently busy with earlier requests it has to be queued until a
    #    connection becomes available.
    # 2. With pipelining enabled:
    #    The request timeout timer starts only once the response for the
    #    preceding request on the connection has arrived.
    # Set to `infinite` to completely disable request timeouts.
    request-timeout = 20 s

    # the "granularity" of timeout checking for both idle connections timeouts
    # as well as request timeouts, should rarely be needed to modify.
    # If set to `infinite` request and connection timeout checking is disabled.
    reaping-cycle = 250 ms

    # If this setting is non-zero the HTTP client connections automatically
    # aggregate incoming response chunks into full HttpResponses before
    # dispatching them to the application.
    # If the size of the aggregated response surpasses the specified limit the
    # HTTP client connection is closed and an error returned.
    # Set to zero to disable automatic request chunk aggregation and have
    # ChunkedResponseStart, MessageChunk and ChunkedMessageEnd messages be
    # dispatched to the application.
    response-chunk-aggregation-limit = 1m

    # Enables/disables an alternative request streaming mode that doesn't
    # use `Transfer-Encoding: chunked` but rather renders the individual
    # MessageChunks coming in from the application as parts of the original
    # request entity.
    # Enabling this mode causes all requests to require an explicit `Content-Length`
    # header for streaming requests.
    # Note that chunkless-streaming is implicitly enabled when streaming
    # HTTP/1.0 requests since they don't support `Transfer-Encoding: chunked`.
    chunkless-streaming = off

    # The initial size if the buffer to render the request headers in.
    # Can be used for fine-tuning request rendering performance but probably
    # doesn't have to be fiddled with in most applications.
    request-header-size-hint = 512

    # For HTTPS connections this setting specified the maximum number of
    # bytes that are encrypted in one go. Large requests are broken down in
    # chunks of this size so as to already begin sending before the request has
    # been encrypted entirely.
    max-encryption-chunk-size = 1m

    # The time period within which the TCP connecting process must be completed.
    # Set to `infinite` to disable.
    connecting-timeout = 10s

    # The proxy configurations to be used for requests with the specified
    # scheme.
    proxy {
      # Proxy settings for unencrypted HTTP requests
      # Set to 'none' to always connect directly, 'default' to use the system
      # settings as described in http://docs.oracle.com/javase/6/docs/technotes/guides/net/proxies.html
      # or specify the proxy host, port and non proxy hosts as demonstrated
      # in the following example:
      # http {
      #   host = myproxy.com
      #   port = 8080
      #   non-proxy-hosts = ["*.direct-access.net"]
      # }
      http = default

      # Proxy settings for HTTPS requests (currently unsupported)
      https = default
    }

    # Enables more verbose DEBUG logging for debugging SSL related issues.
    ssl-tracing = off

    # Modify to tweak parsing settings on the client-side only.
    parsing = ${spray.can.parsing}
  }

  host-connector {
    # The maximum number of parallel connections that an `HttpHostConnector`
    # is allowed to establish to a host. Must be greater than zero.
    max-connections = 4

    # The maximum number of times an `HttpHostConnector` attempts to repeat
    # failed requests (if the request can be safely retried) before
    # giving up and returning an error.
    max-retries = 5

    # Configures redirection following.
    # If set to zero redirection responses will not be followed, i.e. they'll be returned to the user as is.
    # If set to a value > zero redirection responses will be followed up to the given number of times.
    # If the redirection chain is longer than the configured value the first redirection response that is
    # is not followed anymore is returned to the user as is.
    max-redirects = 0

    # If this setting is enabled, the `HttpHostConnector` pipelines requests
    # across connections, otherwise only one single request can be "open"
    # on a particular HTTP connection.
    pipelining = off

    # The time after which an idle `HttpHostConnector` (without open
    # connections) will automatically terminate itself.
    # Set to `infinite` to completely disable idle timeouts.
    idle-timeout = 30 s

    # Modify to tweak client settings for this host-connector only.
    client = ${spray.can.client}
  }

  # The (default) configuration of the HTTP message parser for the server and
  # the client.
  # IMPORTANT: These settings (i.e. children of `spray.can.parsing`) can't be directly
  # overridden in `application.conf` to change the parser settings for client and server
  # altogether (see https://github.com/spray/spray/issues/346). Instead, override the
  # concrete settings beneath `spray.can.server.parsing` and `spray.can.client.parsing`
  # where these settings are copied to.
  parsing {
    # The limits for the various parts of the HTTP message parser.
    max-uri-length             = 2k
    max-response-reason-length = 64
    max-header-name-length     = 64
    max-header-value-length    = 8k
    max-header-count           = 64
    max-content-length         = 8m
    max-chunk-ext-length       = 256
    max-chunk-size             = 1m

    # Sets the strictness mode for parsing request target URIs.
    # The following values are defined:
    #
    # `strict`: RFC3986-compliant URIs are required,
    #     a 400 response is triggered on violations
    #
    # `relaxed`: all visible 7-Bit ASCII chars are allowed
    #
    # `relaxed-with-raw-query`: like `relaxed` but additionally
    #     the URI query is not parsed, but delivered as one raw string
    #     as the `key` value of a single Query structure element.
    #
    uri-parsing-mode = strict

    # Enables/disables the logging of warning messages in case an incoming
    # message (request or response) contains an HTTP header which cannot be
    # parsed into its high-level model class due to incompatible syntax.
    # Note that, independently of this settings, spray will accept messages
    # with such headers as long as the message as a whole would still be legal
    # under the HTTP specification even without this header.
    # If a header cannot be parsed into a high-level model instance it will be
    # provided as a `RawHeader`.
    illegal-header-warnings = on

    # limits for the number of different values per header type that the
    # header cache will hold
    header-cache {
      default = 12
      Content-MD5 = 0
      Date = 0
      If-Match = 0
      If-Modified-Since = 0
      If-None-Match = 0
      If-Range = 0
      If-Unmodified-Since = 0
      User-Agent = 32
    }

    # Sets the size starting from which incoming http-messages will be delivered
    # in chunks regardless of whether chunking is actually used on the wire.
    # Set to infinite to disable auto chunking.
    incoming-auto-chunking-threshold-size = infinite

    # Enables/disables inclusion of an SSL-Session-Info header in parsed
    # messages over SSL transports (i.e., HttpRequest on server side and
    # HttpResponse on client side).
    ssl-session-info-header = off
  }

  # Fully qualified config path which holds the dispatcher configuration
  # to be used for the HttpManager.
  manager-dispatcher = "akka.actor.default-dispatcher"

  # Fully qualified config path which holds the dispatcher configuration
  # to be used for the HttpClientSettingsGroup actors.
  settings-group-dispatcher = "akka.actor.default-dispatcher"

  # Fully qualified config path which holds the dispatcher configuration
  # to be used for the HttpHostConnector actors.
  host-connector-dispatcher = "akka.actor.default-dispatcher"

  # Fully qualified config path which holds the dispatcher configuration
  # to be used for HttpListener actors.
  listener-dispatcher = "akka.actor.default-dispatcher"

  # Fully qualified config path which holds the dispatcher configuration
  # to be used for HttpServerConnection and HttpClientConnection actors.
  connection-dispatcher = "akka.actor.default-dispatcher"
}
#################################
# Akka IO Reference Config File #
#################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

  akka {

    io {

      # By default the select loops run on dedicated threads, hence using a
      # PinnedDispatcher
      pinned-dispatcher {
        type = "PinnedDispatcher"
        executor = "thread-pool-executor"
        thread-pool-executor.allow-core-pool-timeout = off
      }

      tcp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this TCP module; there is
        # no intrinsic general limit, this setting is meant to enable DoS
        # protection by limiting the number of concurrently connected clients.
        # Also note that this is a "soft" limit; in certain cases the implementation
        # will accept a few connections more or a few less than the number configured
        # here. Must be an integer > 0 or "unlimited".
        max-channels = 256000

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of connection that are accepted in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        batch-accept-limit = 10

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The duration a connection actor waits for a `Register` message from
        # its commander before aborting the connection.
        register-timeout = 5s

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        max-received-message-size = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # on which file IO tasks are scheduled
        file-io-dispatcher = "akka.actor.default-dispatcher"

        # The maximum number of bytes (or "unlimited") to transfer in one batch when using
        # `WriteFile` command which uses `FileChannel.transferTo` to pipe files to a TCP socket.
        # On some OS like Linux `FileChannel.transferTo` may block for a long time when network
        # IO is faster than file IO. Decreasing the value may improve fairness while increasing
        # may improve throughput.
        file-io-transferTo-limit = 512 KiB

        # The number of times to retry the `finishConnect` call after being notified about
        # OP_CONNECT. Retries are needed if the OP_CONNECT notification doesn't imply that
        # `finishConnect` will succeed. However, on Android this assumption isn't true.
        finish-connect-retries = 5
      }

      udp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }

      udp-connected {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }
    }
  }
  ####################################
  # spray-util Reference Config File #
  ####################################

  # This is the reference config file that contains all the default settings.
  # Make your edits/overrides in your application.conf.

  spray {

    # Always contains the deployed version of spray.
    # Referenced, for example, from the `spray.can.server.server-header` setting.
    version = "1.3.2"
  }
  #######################################
  # spray-routing Reference Config File #
  #######################################

  # This is the reference config file that contains all the default settings.
  # Make your edits/overrides in your application.conf.

  spray.routing {

    # Enables/disables the returning of more detailed error messages to the
    # client in the error response
    # Should be disabled for browser-facing APIs due to the risk of XSS attacks
    # and (probably) enabled for internal or non-browser APIs
    # (Note that spray will always produce log messages containing the full error details)
    verbose-error-messages = off

    # the minimal file size triggering file content streaming
    # set to zero to disable automatic file-chunking in the FileAndResourceDirectives
    file-chunking-threshold-size = 128k

    # the size of an individual chunk when streaming file content
    file-chunking-chunk-size = 128k

    # Enables/disables ETag and `If-Modified-Since` support for FileAndResourceDirectives
    file-get-conditional = on

    # Enables/disables the rendering of the "rendered by" footer in directory listings
    render-vanity-footer = yes

    # a config section holding plain-text user/password entries
    # for the default FromConfigUserPassAuthenticator
    users {
      # bob = secret
    }

    # the maximum size between two requested ranges.
    # Ranges with less space in between will be coalesced.
    range-coalescing-threshold = 80

    # the maximum number of allowed ranges per request.
    # Requests with more ranges will be rejected due to DOS suspicion.
    range-count-limit = 16
  }
  ####################################
  # Akka Actor Reference Config File #
  ####################################

  # This is the reference config file that contains all the default settings.
  # Make your edits/overrides in your application.conf.

  akka {
    # Akka version, checked against the runtime version of Akka.
    version = "2.3.6"

    # Home directory of Akka, modules in the deploy directory will be loaded
    home = ""

    # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
    # to STDOUT)
    loggers = ["de.frosner.dds.akka.event.Logging$DefaultLogger"]

    # Loggers are created and registered synchronously during ActorSystem
    # start-up, and since they are actors, this timeout is used to bound the
    # waiting time
    logger-startup-timeout = 5s

    # Log level used by the configured loggers (see "loggers") as soon
    # as they have been started; before that, see "stdout-loglevel"
    # Options: OFF, ERROR, WARNING, INFO, DEBUG
    loglevel = "WARNING"

    # Log level for the very basic logger activated during ActorSystem startup.
    # This logger prints the log messages to stdout (System.out).
    # Options: OFF, ERROR, WARNING, INFO, DEBUG
    stdout-loglevel = "WARNING"

    # Log the complete configuration at INFO level when the actor system is started.
    # This is useful when you are uncertain of what configuration is used.
    log-config-on-start = off

    # Log at info level when messages are sent to dead letters.
    # Possible values:
    # on: all dead letters are logged
    # off: no logging of dead letters
    # n: positive integer, number of dead letters that will be logged
    log-dead-letters = 10

    # Possibility to turn off logging of dead letters while the actor system
    # is shutting down. Logging is only done when enabled by 'log-dead-letters'
    # setting.
    log-dead-letters-during-shutdown = on

    # List FQCN of extensions which shall be loaded at actor system startup.
    # Should be on the format: 'extensions = ["foo", "bar"]' etc.
    # See the Akka Documentation for more info about Extensions
    extensions = []

    # Toggles whether threads created by this ActorSystem should be daemons or not
    daemonic = off

    # JVM shutdown, System.exit(-1), in case of a fatal error,
    # such as OutOfMemoryError
    jvm-exit-on-fatal-error = on

    actor {

      # FQCN of the ActorRefProvider to be used; the below is the built-in default,
      # another one is akka.remote.RemoteActorRefProvider in the akka-remote bundle.
      provider = "de.frosner.dds.akka.actor.LocalActorRefProvider"

      # The guardian "/user" will use this class to obtain its supervisorStrategy.
      # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
      # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
      guardian-supervisor-strategy = "de.frosner.dds.akka.actor.DefaultSupervisorStrategy"

      # Timeout for ActorSystem.actorOf
      creation-timeout = 20s

      # Frequency with which stopping actors are prodded in case they had to be
      # removed from their parents
      reaper-interval = 5s

      # Serializes and deserializes (non-primitive) messages to ensure immutability,
      # this is only intended for testing.
      serialize-messages = off

      # Serializes and deserializes creators (in Props) to ensure that they can be
      # sent over the network, this is only intended for testing. Purely local deployments
      # as marked with deploy.scope == LocalScope are exempt from verification.
      serialize-creators = off

      # Timeout for send operations to top-level actors which are in the process
      # of being started. This is only relevant if using a bounded mailbox or the
      # CallingThreadDispatcher for a top-level actor.
      unstarted-push-timeout = 10s

      typed {
        # Default timeout for typed actor methods with non-void return type
        timeout = 5s
      }

      # Mapping between ´deployment.router' short names to fully qualified class names
      router.type-mapping {
        from-code = "de.frosner.dds.akka.routing.NoRouter"
        round-robin-pool = "de.frosner.dds.akka.routing.RoundRobinPool"
        round-robin-group = "de.frosner.dds.akka.routing.RoundRobinGroup"
        random-pool = "de.frosner.dds.akka.routing.RandomPool"
        random-group = "de.frosner.dds.akka.routing.RandomGroup"
        balancing-pool = "de.frosner.dds.akka.routing.BalancingPool"
        smallest-mailbox-pool = "de.frosner.dds.akka.routing.SmallestMailboxPool"
        broadcast-pool = "de.frosner.dds.akka.routing.BroadcastPool"
        broadcast-group = "de.frosner.dds.akka.routing.BroadcastGroup"
        scatter-gather-pool = "de.frosner.dds.akka.routing.ScatterGatherFirstCompletedPool"
        scatter-gather-group = "de.frosner.dds.akka.routing.ScatterGatherFirstCompletedGroup"
        tail-chopping-pool = "de.frosner.dds.akka.routing.TailChoppingPool"
        tail-chopping-group = "de.frosner.dds.akka.routing.TailChoppingGroup"
        consistent-hashing-pool = "de.frosner.dds.akka.routing.ConsistentHashingPool"
        consistent-hashing-group = "de.frosner.dds.akka.routing.ConsistentHashingGroup"
      }

      deployment {

        # deployment id pattern - on the format: /parent/child etc.
        default {

          # The id of the dispatcher to use for this actor.
          # If undefined or empty the dispatcher specified in code
          # (Props.withDispatcher) is used, or default-dispatcher if not
          # specified at all.
          dispatcher = ""

          # The id of the mailbox to use for this actor.
          # If undefined or empty the default mailbox of the configured dispatcher
          # is used or if there is no mailbox configuration the mailbox specified
          # in code (Props.withMailbox) is used.
          # If there is a mailbox defined in the configured dispatcher then that
          # overrides this setting.
          mailbox = ""

          # routing (load-balance) scheme to use
          # - available: "from-code", "round-robin", "random", "smallest-mailbox",
          #              "scatter-gather", "broadcast"
          # - or:        Fully qualified class name of the router class.
          #              The class must extend akka.routing.CustomRouterConfig and
          #              have a public constructor with com.typesafe.config.Config
          #              and optional akka.actor.DynamicAccess parameter.
          # - default is "from-code";
          # Whether or not an actor is transformed to a Router is decided in code
          # only (Props.withRouter). The type of router can be overridden in the
          # configuration; specifying "from-code" means that the values specified
          # in the code shall be used.
          # In case of routing, the actors to be routed to can be specified
          # in several ways:
          # - nr-of-instances: will create that many children
          # - routees.paths: will route messages to these paths using ActorSelection,
          #   i.e. will not create children
          # - resizer: dynamically resizable number of routees as specified in
          #   resizer below
          router = "from-code"

          # number of children to create in case of a router;
          # this setting is ignored if routees.paths is given
          nr-of-instances = 1

          # within is the timeout used for routers containing future calls
          within = 5 seconds

          # number of virtual nodes per node for consistent-hashing router
          virtual-nodes-factor = 10

          tail-chopping-router {
            # interval is duration between sending message to next routee
            interval = 10 milliseconds
          }

          routees {
            # Alternatively to giving nr-of-instances you can specify the full
            # paths of those actors which should be routed to. This setting takes
            # precedence over nr-of-instances
            paths = []
          }

          # To use a dedicated dispatcher for the routees of the pool you can
          # define the dispatcher configuration inline with the property name
          # 'pool-dispatcher' in the deployment section of the router.
          # For example:
          # pool-dispatcher {
          #   fork-join-executor.parallelism-min = 5
          #   fork-join-executor.parallelism-max = 5
          # }

          # Routers with dynamically resizable number of routees; this feature is
          # enabled by including (parts of) this section in the deployment
          resizer {

            enabled = off

            # The fewest number of routees the router should ever have.
            lower-bound = 1

            # The most number of routees the router should ever have.
            # Must be greater than or equal to lower-bound.
            upper-bound = 10

            # Threshold used to evaluate if a routee is considered to be busy
            # (under pressure). Implementation depends on this value (default is 1).
            # 0:   number of routees currently processing a message.
            # 1:   number of routees currently processing a message has
            #      some messages in mailbox.
            # > 1: number of routees with at least the configured pressure-threshold
            #      messages in their mailbox. Note that estimating mailbox size of
            #      default UnboundedMailbox is O(N) operation.
            pressure-threshold = 1

            # Percentage to increase capacity whenever all routees are busy.
            # For example, 0.2 would increase 20% (rounded up), i.e. if current
            # capacity is 6 it will request an increase of 2 more routees.
            rampup-rate = 0.2

            # Minimum fraction of busy routees before backing off.
            # For example, if this is 0.3, then we'll remove some routees only when
            # less than 30% of routees are busy, i.e. if current capacity is 10 and
            # 3 are busy then the capacity is unchanged, but if 2 or less are busy
            # the capacity is decreased.
            # Use 0.0 or negative to avoid removal of routees.
            backoff-threshold = 0.3

            # Fraction of routees to be removed when the resizer reaches the
            # backoffThreshold.
            # For example, 0.1 would decrease 10% (rounded up), i.e. if current
            # capacity is 9 it will request an decrease of 1 routee.
            backoff-rate = 0.1

            # Number of messages between resize operation.
            # Use 1 to resize before each message.
            messages-per-resize = 10
          }
        }
      }

      default-dispatcher {
        # Must be one of the following
        # Dispatcher, PinnedDispatcher, or a FQCN to a class inheriting
        # MessageDispatcherConfigurator with a public constructor with
        # both com.typesafe.config.Config parameter and
        # akka.dispatch.DispatcherPrerequisites parameters.
        # PinnedDispatcher must be used together with executor=thread-pool-executor.
        type = "Dispatcher"

        # Which kind of ExecutorService to use for this dispatcher
        # Valid options:
        #  - "default-executor" requires a "default-executor" section
        #  - "fork-join-executor" requires a "fork-join-executor" section
        #  - "thread-pool-executor" requires a "thread-pool-executor" section
        #  - A FQCN of a class extending ExecutorServiceConfigurator
        executor = "default-executor"

        # This will be used if you have set "executor = "default-executor"".
        # If an ActorSystem is created with a given ExecutionContext, this
        # ExecutionContext will be used as the default executor for all
        # dispatchers in the ActorSystem configured with
        # executor = "default-executor". Note that "default-executor"
        # is the default value for executor, and therefore used if not
        # specified otherwise. If no ExecutionContext is given,
        # the executor configured in "fallback" will be used.
        default-executor {
          fallback = "fork-join-executor"
        }

        # This will be used if you have set "executor = "fork-join-executor""
        fork-join-executor {
          # Min number of threads to cap factor-based parallelism number to
          parallelism-min = 8

          # The parallelism factor is used to determine thread pool size using the
          # following formula: ceil(available processors * factor). Resulting size
          # is then bounded by the parallelism-min and parallelism-max values.
          parallelism-factor = 3.0

          # Max number of threads to cap factor-based parallelism number to
          parallelism-max = 64
        }

        # This will be used if you have set "executor = "thread-pool-executor""
        thread-pool-executor {
          # Keep alive time for threads
          keep-alive-time = 60s

          # Min number of threads to cap factor-based core number to
          core-pool-size-min = 8

          # The core pool size factor is used to determine thread pool core size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the core-pool-size-min and
          # core-pool-size-max values.
          core-pool-size-factor = 3.0

          # Max number of threads to cap factor-based number to
          core-pool-size-max = 64

          # Minimum number of threads to cap factor-based max number to
          # (if using a bounded task queue)
          max-pool-size-min = 8

          # Max no of threads (if using a bounded task queue) is determined by
          # calculating: ceil(available processors * factor)
          max-pool-size-factor  = 3.0

          # Max number of threads to cap factor-based max number to
          # (if using a  bounded task queue)
          max-pool-size-max = 64

          # Specifies the bounded capacity of the task queue (< 1 == unbounded)
          task-queue-size = -1

          # Specifies which type of task queue will be used, can be "array" or
          # "linked" (default)
          task-queue-type = "linked"

          # Allow core threads to time out
          allow-core-timeout = on
        }

        # How long time the dispatcher will wait for new actors until it shuts down
        shutdown-timeout = 1s

        # Throughput defines the number of messages that are processed in a batch
        # before the thread is returned to the pool. Set to 1 for as fair as possible.
        throughput = 5

        # Throughput deadline for Dispatcher, set to 0 or negative for no deadline
        throughput-deadline-time = 0ms

        # For BalancingDispatcher: If the balancing dispatcher should attempt to
        # schedule idle actors using the same dispatcher when a message comes in,
        # and the dispatchers ExecutorService is not fully busy already.
        attempt-teamwork = on

        # If this dispatcher requires a specific type of mailbox, specify the
        # fully-qualified class name here; the actually created mailbox will
        # be a subtype of this type. The empty string signifies no requirement.
        mailbox-requirement = ""
      }

      default-mailbox {
        # FQCN of the MailboxType. The Class of the FQCN must have a public
        # constructor with
        # (akka.actor.ActorSystem.Settings, com.typesafe.config.Config) parameters.
        mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedMailbox"

        # If the mailbox is bounded then it uses this setting to determine its
        # capacity. The provided value must be positive.
        # NOTICE:
        # Up to version 2.1 the mailbox type was determined based on this setting;
        # this is no longer the case, the type must explicitly be a bounded mailbox.
        mailbox-capacity = 1000

        # If the mailbox is bounded then this is the timeout for enqueueing
        # in case the mailbox is full. Negative values signify infinite
        # timeout, which should be avoided as it bears the risk of dead-lock.
        mailbox-push-timeout-time = 10s

        # For Actor with Stash: The default capacity of the stash.
        # If negative (or zero) then an unbounded stash is used (default)
        # If positive then a bounded stash is used and the capacity is set using
        # the property
        stash-capacity = -1
      }

      mailbox {
        # Mapping between message queue semantics and mailbox configurations.
        # Used by akka.dispatch.RequiresMessageQueue[T] to enforce different
        # mailbox types on actors.
        # If your Actor implements RequiresMessageQueue[T], then when you create
        # an instance of that actor its mailbox type will be decided by looking
        # up a mailbox configuration via T in this mapping
        requirements {
          "de.frosner.dds.akka.dispatch.UnboundedMessageQueueSemantics" =
            akka.actor.mailbox.unbounded-queue-based
          "de.frosner.dds.akka.dispatch.BoundedMessageQueueSemantics" =
            akka.dds.actor.mailbox.bounded-queue-based
          "de.frosner.dds.akka.dispatch.DequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.unbounded-deque-based
          "de.frosner.dds.akka.dispatch.UnboundedDequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.unbounded-deque-based
          "de.frosner.dds.akka.dispatch.BoundedDequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.bounded-deque-based
          "de.frosner.dds.akka.dispatch.MultipleConsumerSemantics" =
            akka.dds.actor.mailbox.unbounded-queue-based
        }

        unbounded-queue-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedMailbox"
        }

        bounded-queue-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.BoundedMailbox"
        }

        unbounded-deque-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedDequeBasedMailbox"
        }

        bounded-deque-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.BoundedDequeBasedMailbox"
        }
      }

      debug {
        # enable function of Actor.loggable(), which is to log any received message
        # at DEBUG level, see the “Testing Actor Systems” section of the Akka
        # Documentation at http://akka.io/docs
        receive = off

        # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
        autoreceive = off

        # enable DEBUG logging of actor lifecycle changes
        lifecycle = off

        # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
        fsm = off

        # enable DEBUG logging of subscription changes on the eventStream
        event-stream = off

        # enable DEBUG logging of unhandled messages
        unhandled = off

        # enable WARN logging of misconfigured routers
        router-misconfiguration = off
      }

      # Entries for pluggable serializers and their bindings.
      serializers {
        java = "de.frosner.dds.akka.serialization.JavaSerializer"
        bytes = "de.frosner.dds.akka.serialization.ByteArraySerializer"
      }

      # Class to Serializer binding. You only need to specify the name of an
      # interface or abstract base class of the messages. In case of ambiguity it
      # is using the most specific configured class, or giving a warning and
      # choosing the “first” one.
      #
      # To disable one of the default serializers, assign its class to "none", like
      # "java.io.Serializable" = none
      serialization-bindings {
        "[B" = bytes
        "java.io.Serializable" = java
      }

      # Configuration items which are used by the akka.actor.ActorDSL._ methods
      dsl {
        # Maximum queue size of the actor created by newInbox(); this protects
        # against faulty programs which use select() and consistently miss messages
        inbox-size = 1000

        # Default timeout to assume for operations like Inbox.receive et al
        default-timeout = 5s
      }
    }

    # Used to set the behavior of the scheduler.
    # Changing the default values may change the system behavior drastically so make
    # sure you know what you're doing! See the Scheduler section of the Akka
    # Documentation for more details.
    scheduler {
      # The LightArrayRevolverScheduler is used as the default scheduler in the
      # system. It does not execute the scheduled tasks on exact time, but on every
      # tick, it will run everything that is (over)due. You can increase or decrease
      # the accuracy of the execution timing by specifying smaller or larger tick
      # duration. If you are scheduling a lot of tasks you should consider increasing
      # the ticks per wheel.
      # Note that it might take up to 1 tick to stop the Timer, so setting the
      # tick-duration to a high value will make shutting down the actor system
      # take longer.
      tick-duration = 10ms

      # The timer uses a circular wheel of buckets to store the timer tasks.
      # This should be set such that the majority of scheduled timeouts (for high
      # scheduling frequency) will be shorter than one rotation of the wheel
      # (ticks-per-wheel * ticks-duration)
      # THIS MUST BE A POWER OF TWO!
      ticks-per-wheel = 512

      # This setting selects the timer implementation which shall be loaded at
      # system start-up.
      # The class given here must implement the akka.actor.Scheduler interface
      # and offer a public constructor which takes three arguments:
      #  1) com.typesafe.config.Config
      #  2) akka.event.LoggingAdapter
      #  3) java.util.concurrent.ThreadFactory
      implementation = de.frosner.dds.akka.actor.LightArrayRevolverScheduler

      # When shutting down the scheduler, there will typically be a thread which
      # needs to be stopped, and this timeout determines how long to wait for
      # that to happen. In case of timeout the shutdown of the actor system will
      # proceed without running possibly still enqueued tasks.
      shutdown-timeout = 5s
    }

    io {

      # By default the select loops run on dedicated threads, hence using a
      # PinnedDispatcher
      pinned-dispatcher {
        type = "PinnedDispatcher"
        executor = "thread-pool-executor"
        thread-pool-executor.allow-core-pool-timeout = off
      }

      tcp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this TCP module; there is
        # no intrinsic general limit, this setting is meant to enable DoS
        # protection by limiting the number of concurrently connected clients.
        # Also note that this is a "soft" limit; in certain cases the implementation
        # will accept a few connections more or a few less than the number configured
        # here. Must be an integer > 0 or "unlimited".
        max-channels = 256000

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of connection that are accepted in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        batch-accept-limit = 10

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The duration a connection actor waits for a `Register` message from
        # its commander before aborting the connection.
        register-timeout = 5s

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        max-received-message-size = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # on which file IO tasks are scheduled
        file-io-dispatcher = "akka.actor.default-dispatcher"

        # The maximum number of bytes (or "unlimited") to transfer in one batch
        # when using `WriteFile` command which uses `FileChannel.transferTo` to
        # pipe files to a TCP socket. On some OS like Linux `FileChannel.transferTo`
        # may block for a long time when network IO is faster than file IO.
        # Decreasing the value may improve fairness while increasing may improve
        # throughput.
        file-io-transferTo-limit = 512 KiB

        # The number of times to retry the `finishConnect` call after being notified about
        # OP_CONNECT. Retries are needed if the OP_CONNECT notification doesn't imply that
        # `finishConnect` will succeed, which is the case on Android.
        finish-connect-retries = 5
      }

      udp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }

      udp-connected {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }

    }


  }

de.frosner.dds {

  akka {
    # Akka version, checked against the runtime version of Akka.
    version = "2.3.6"

    # Home directory of Akka, modules in the deploy directory will be loaded
    home = ""

    # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
    # to STDOUT)
    loggers = ["de.frosner.dds.akka.event.Logging$DefaultLogger"]

    # Loggers are created and registered synchronously during ActorSystem
    # start-up, and since they are actors, this timeout is used to bound the
    # waiting time
    logger-startup-timeout = 5s

    # Log level used by the configured loggers (see "loggers") as soon
    # as they have been started; before that, see "stdout-loglevel"
    # Options: OFF, ERROR, WARNING, INFO, DEBUG
    loglevel = "INFO"

    # Log level for the very basic logger activated during ActorSystem startup.
    # This logger prints the log messages to stdout (System.out).
    # Options: OFF, ERROR, WARNING, INFO, DEBUG
    stdout-loglevel = "WARNING"

    # Log the complete configuration at INFO level when the actor system is started.
    # This is useful when you are uncertain of what configuration is used.
    log-config-on-start = off

    # Log at info level when messages are sent to dead letters.
    # Possible values:
    # on: all dead letters are logged
    # off: no logging of dead letters
    # n: positive integer, number of dead letters that will be logged
    log-dead-letters = 10

    # Possibility to turn off logging of dead letters while the actor system
    # is shutting down. Logging is only done when enabled by 'log-dead-letters'
    # setting.
    log-dead-letters-during-shutdown = on

    # List FQCN of extensions which shall be loaded at actor system startup.
    # Should be on the format: 'extensions = ["foo", "bar"]' etc.
    # See the Akka Documentation for more info about Extensions
    extensions = []

    # Toggles whether threads created by this ActorSystem should be daemons or not
    daemonic = off

    # JVM shutdown, System.exit(-1), in case of a fatal error,
    # such as OutOfMemoryError
    jvm-exit-on-fatal-error = on

    actor {

      # FQCN of the ActorRefProvider to be used; the below is the built-in default,
      # another one is akka.remote.RemoteActorRefProvider in the akka-remote bundle.
      provider = "de.frosner.dds.akka.actor.LocalActorRefProvider"

      # The guardian "/user" will use this class to obtain its supervisorStrategy.
      # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
      # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
      guardian-supervisor-strategy = "de.frosner.dds.akka.actor.DefaultSupervisorStrategy"

      # Timeout for ActorSystem.actorOf
      creation-timeout = 20s

      # Frequency with which stopping actors are prodded in case they had to be
      # removed from their parents
      reaper-interval = 5s

      # Serializes and deserializes (non-primitive) messages to ensure immutability,
      # this is only intended for testing.
      serialize-messages = off

      # Serializes and deserializes creators (in Props) to ensure that they can be
      # sent over the network, this is only intended for testing. Purely local deployments
      # as marked with deploy.scope == LocalScope are exempt from verification.
      serialize-creators = off

      # Timeout for send operations to top-level actors which are in the process
      # of being started. This is only relevant if using a bounded mailbox or the
      # CallingThreadDispatcher for a top-level actor.
      unstarted-push-timeout = 10s

      typed {
        # Default timeout for typed actor methods with non-void return type
        timeout = 5s
      }

      # Mapping between ´deployment.router' short names to fully qualified class names
      router.type-mapping {
        from-code = "de.frosner.dds.akka.routing.NoRouter"
        round-robin-pool = "de.frosner.dds.akka.routing.RoundRobinPool"
        round-robin-group = "de.frosner.dds.akka.routing.RoundRobinGroup"
        random-pool = "de.frosner.dds.akka.routing.RandomPool"
        random-group = "de.frosner.dds.akka.routing.RandomGroup"
        balancing-pool = "de.frosner.dds.akka.routing.BalancingPool"
        smallest-mailbox-pool = "de.frosner.dds.akka.routing.SmallestMailboxPool"
        broadcast-pool = "de.frosner.dds.akka.routing.BroadcastPool"
        broadcast-group = "de.frosner.dds.akka.routing.BroadcastGroup"
        scatter-gather-pool = "de.frosner.dds.akka.routing.ScatterGatherFirstCompletedPool"
        scatter-gather-group = "de.frosner.dds.akka.routing.ScatterGatherFirstCompletedGroup"
        tail-chopping-pool = "de.frosner.dds.akka.routing.TailChoppingPool"
        tail-chopping-group = "de.frosner.dds.akka.routing.TailChoppingGroup"
        consistent-hashing-pool = "de.frosner.dds.akka.routing.ConsistentHashingPool"
        consistent-hashing-group = "de.frosner.dds.akka.routing.ConsistentHashingGroup"
      }

      deployment {

        # deployment id pattern - on the format: /parent/child etc.
        default {

          # The id of the dispatcher to use for this actor.
          # If undefined or empty the dispatcher specified in code
          # (Props.withDispatcher) is used, or default-dispatcher if not
          # specified at all.
          dispatcher = ""

          # The id of the mailbox to use for this actor.
          # If undefined or empty the default mailbox of the configured dispatcher
          # is used or if there is no mailbox configuration the mailbox specified
          # in code (Props.withMailbox) is used.
          # If there is a mailbox defined in the configured dispatcher then that
          # overrides this setting.
          mailbox = ""

          # routing (load-balance) scheme to use
          # - available: "from-code", "round-robin", "random", "smallest-mailbox",
          #              "scatter-gather", "broadcast"
          # - or:        Fully qualified class name of the router class.
          #              The class must extend akka.routing.CustomRouterConfig and
          #              have a public constructor with com.typesafe.config.Config
          #              and optional akka.actor.DynamicAccess parameter.
          # - default is "from-code";
          # Whether or not an actor is transformed to a Router is decided in code
          # only (Props.withRouter). The type of router can be overridden in the
          # configuration; specifying "from-code" means that the values specified
          # in the code shall be used.
          # In case of routing, the actors to be routed to can be specified
          # in several ways:
          # - nr-of-instances: will create that many children
          # - routees.paths: will route messages to these paths using ActorSelection,
          #   i.e. will not create children
          # - resizer: dynamically resizable number of routees as specified in
          #   resizer below
          router = "from-code"

          # number of children to create in case of a router;
          # this setting is ignored if routees.paths is given
          nr-of-instances = 1

          # within is the timeout used for routers containing future calls
          within = 5 seconds

          # number of virtual nodes per node for consistent-hashing router
          virtual-nodes-factor = 10

          tail-chopping-router {
            # interval is duration between sending message to next routee
            interval = 10 milliseconds
          }

          routees {
            # Alternatively to giving nr-of-instances you can specify the full
            # paths of those actors which should be routed to. This setting takes
            # precedence over nr-of-instances
            paths = []
          }

          # To use a dedicated dispatcher for the routees of the pool you can
          # define the dispatcher configuration inline with the property name
          # 'pool-dispatcher' in the deployment section of the router.
          # For example:
          # pool-dispatcher {
          #   fork-join-executor.parallelism-min = 5
          #   fork-join-executor.parallelism-max = 5
          # }

          # Routers with dynamically resizable number of routees; this feature is
          # enabled by including (parts of) this section in the deployment
          resizer {

            enabled = off

            # The fewest number of routees the router should ever have.
            lower-bound = 1

            # The most number of routees the router should ever have.
            # Must be greater than or equal to lower-bound.
            upper-bound = 10

            # Threshold used to evaluate if a routee is considered to be busy
            # (under pressure). Implementation depends on this value (default is 1).
            # 0:   number of routees currently processing a message.
            # 1:   number of routees currently processing a message has
            #      some messages in mailbox.
            # > 1: number of routees with at least the configured pressure-threshold
            #      messages in their mailbox. Note that estimating mailbox size of
            #      default UnboundedMailbox is O(N) operation.
            pressure-threshold = 1

            # Percentage to increase capacity whenever all routees are busy.
            # For example, 0.2 would increase 20% (rounded up), i.e. if current
            # capacity is 6 it will request an increase of 2 more routees.
            rampup-rate = 0.2

            # Minimum fraction of busy routees before backing off.
            # For example, if this is 0.3, then we'll remove some routees only when
            # less than 30% of routees are busy, i.e. if current capacity is 10 and
            # 3 are busy then the capacity is unchanged, but if 2 or less are busy
            # the capacity is decreased.
            # Use 0.0 or negative to avoid removal of routees.
            backoff-threshold = 0.3

            # Fraction of routees to be removed when the resizer reaches the
            # backoffThreshold.
            # For example, 0.1 would decrease 10% (rounded up), i.e. if current
            # capacity is 9 it will request an decrease of 1 routee.
            backoff-rate = 0.1

            # Number of messages between resize operation.
            # Use 1 to resize before each message.
            messages-per-resize = 10
          }
        }
      }

      default-dispatcher {
        # Must be one of the following
        # Dispatcher, PinnedDispatcher, or a FQCN to a class inheriting
        # MessageDispatcherConfigurator with a public constructor with
        # both com.typesafe.config.Config parameter and
        # akka.dispatch.DispatcherPrerequisites parameters.
        # PinnedDispatcher must be used together with executor=thread-pool-executor.
        type = "Dispatcher"

        # Which kind of ExecutorService to use for this dispatcher
        # Valid options:
        #  - "default-executor" requires a "default-executor" section
        #  - "fork-join-executor" requires a "fork-join-executor" section
        #  - "thread-pool-executor" requires a "thread-pool-executor" section
        #  - A FQCN of a class extending ExecutorServiceConfigurator
        executor = "default-executor"

        # This will be used if you have set "executor = "default-executor"".
        # If an ActorSystem is created with a given ExecutionContext, this
        # ExecutionContext will be used as the default executor for all
        # dispatchers in the ActorSystem configured with
        # executor = "default-executor". Note that "default-executor"
        # is the default value for executor, and therefore used if not
        # specified otherwise. If no ExecutionContext is given,
        # the executor configured in "fallback" will be used.
        default-executor {
          fallback = "fork-join-executor"
        }

        # This will be used if you have set "executor = "fork-join-executor""
        fork-join-executor {
          # Min number of threads to cap factor-based parallelism number to
          parallelism-min = 8

          # The parallelism factor is used to determine thread pool size using the
          # following formula: ceil(available processors * factor). Resulting size
          # is then bounded by the parallelism-min and parallelism-max values.
          parallelism-factor = 3.0

          # Max number of threads to cap factor-based parallelism number to
          parallelism-max = 64
        }

        # This will be used if you have set "executor = "thread-pool-executor""
        thread-pool-executor {
          # Keep alive time for threads
          keep-alive-time = 60s

          # Min number of threads to cap factor-based core number to
          core-pool-size-min = 8

          # The core pool size factor is used to determine thread pool core size
          # using the following formula: ceil(available processors * factor).
          # Resulting size is then bounded by the core-pool-size-min and
          # core-pool-size-max values.
          core-pool-size-factor = 3.0

          # Max number of threads to cap factor-based number to
          core-pool-size-max = 64

          # Minimum number of threads to cap factor-based max number to
          # (if using a bounded task queue)
          max-pool-size-min = 8

          # Max no of threads (if using a bounded task queue) is determined by
          # calculating: ceil(available processors * factor)
          max-pool-size-factor  = 3.0

          # Max number of threads to cap factor-based max number to
          # (if using a  bounded task queue)
          max-pool-size-max = 64

          # Specifies the bounded capacity of the task queue (< 1 == unbounded)
          task-queue-size = -1

          # Specifies which type of task queue will be used, can be "array" or
          # "linked" (default)
          task-queue-type = "linked"

          # Allow core threads to time out
          allow-core-timeout = on
        }

        # How long time the dispatcher will wait for new actors until it shuts down
        shutdown-timeout = 1s

        # Throughput defines the number of messages that are processed in a batch
        # before the thread is returned to the pool. Set to 1 for as fair as possible.
        throughput = 5

        # Throughput deadline for Dispatcher, set to 0 or negative for no deadline
        throughput-deadline-time = 0ms

        # For BalancingDispatcher: If the balancing dispatcher should attempt to
        # schedule idle actors using the same dispatcher when a message comes in,
        # and the dispatchers ExecutorService is not fully busy already.
        attempt-teamwork = on

        # If this dispatcher requires a specific type of mailbox, specify the
        # fully-qualified class name here; the actually created mailbox will
        # be a subtype of this type. The empty string signifies no requirement.
        mailbox-requirement = ""
      }

      default-mailbox {
        # FQCN of the MailboxType. The Class of the FQCN must have a public
        # constructor with
        # (akka.actor.ActorSystem.Settings, com.typesafe.config.Config) parameters.
        mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedMailbox"

        # If the mailbox is bounded then it uses this setting to determine its
        # capacity. The provided value must be positive.
        # NOTICE:
        # Up to version 2.1 the mailbox type was determined based on this setting;
        # this is no longer the case, the type must explicitly be a bounded mailbox.
        mailbox-capacity = 1000

        # If the mailbox is bounded then this is the timeout for enqueueing
        # in case the mailbox is full. Negative values signify infinite
        # timeout, which should be avoided as it bears the risk of dead-lock.
        mailbox-push-timeout-time = 10s

        # For Actor with Stash: The default capacity of the stash.
        # If negative (or zero) then an unbounded stash is used (default)
        # If positive then a bounded stash is used and the capacity is set using
        # the property
        stash-capacity = -1
      }

      mailbox {
        # Mapping between message queue semantics and mailbox configurations.
        # Used by akka.dispatch.RequiresMessageQueue[T] to enforce different
        # mailbox types on actors.
        # If your Actor implements RequiresMessageQueue[T], then when you create
        # an instance of that actor its mailbox type will be decided by looking
        # up a mailbox configuration via T in this mapping
        requirements {
          "de.frosner.dds.akka.dispatch.UnboundedMessageQueueSemantics" =
            akka.actor.mailbox.unbounded-queue-based
          "de.frosner.dds.akka.dispatch.BoundedMessageQueueSemantics" =
            akka.dds.actor.mailbox.bounded-queue-based
          "de.frosner.dds.akka.dispatch.DequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.unbounded-deque-based
          "de.frosner.dds.akka.dispatch.UnboundedDequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.unbounded-deque-based
          "de.frosner.dds.akka.dispatch.BoundedDequeBasedMessageQueueSemantics" =
            akka.dds.actor.mailbox.bounded-deque-based
          "de.frosner.dds.akka.dispatch.MultipleConsumerSemantics" =
            akka.dds.actor.mailbox.unbounded-queue-based
        }

        unbounded-queue-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedMailbox"
        }

        bounded-queue-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.BoundedMailbox"
        }

        unbounded-deque-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.UnboundedDequeBasedMailbox"
        }

        bounded-deque-based {
          # FQCN of the MailboxType, The Class of the FQCN must have a public
          # constructor with (akka.actor.ActorSystem.Settings,
          # com.typesafe.config.Config) parameters.
          mailbox-type = "de.frosner.dds.akka.dispatch.BoundedDequeBasedMailbox"
        }
      }

      debug {
        # enable function of Actor.loggable(), which is to log any received message
        # at DEBUG level, see the “Testing Actor Systems” section of the Akka
        # Documentation at http://akka.io/docs
        receive = off

        # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
        autoreceive = off

        # enable DEBUG logging of actor lifecycle changes
        lifecycle = off

        # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
        fsm = off

        # enable DEBUG logging of subscription changes on the eventStream
        event-stream = off

        # enable DEBUG logging of unhandled messages
        unhandled = off

        # enable WARN logging of misconfigured routers
        router-misconfiguration = off
      }

      # Entries for pluggable serializers and their bindings.
      serializers {
        java = "de.frosner.dds.akka.serialization.JavaSerializer"
        bytes = "de.frosner.dds.akka.serialization.ByteArraySerializer"
      }

      # Class to Serializer binding. You only need to specify the name of an
      # interface or abstract base class of the messages. In case of ambiguity it
      # is using the most specific configured class, or giving a warning and
      # choosing the “first” one.
      #
      # To disable one of the default serializers, assign its class to "none", like
      # "java.io.Serializable" = none
      serialization-bindings {
        "[B" = bytes
        "java.io.Serializable" = java
      }

      # Configuration items which are used by the akka.actor.ActorDSL._ methods
      dsl {
        # Maximum queue size of the actor created by newInbox(); this protects
        # against faulty programs which use select() and consistently miss messages
        inbox-size = 1000

        # Default timeout to assume for operations like Inbox.receive et al
        default-timeout = 5s
      }
    }

    # Used to set the behavior of the scheduler.
    # Changing the default values may change the system behavior drastically so make
    # sure you know what you're doing! See the Scheduler section of the Akka
    # Documentation for more details.
    scheduler {
      # The LightArrayRevolverScheduler is used as the default scheduler in the
      # system. It does not execute the scheduled tasks on exact time, but on every
      # tick, it will run everything that is (over)due. You can increase or decrease
      # the accuracy of the execution timing by specifying smaller or larger tick
      # duration. If you are scheduling a lot of tasks you should consider increasing
      # the ticks per wheel.
      # Note that it might take up to 1 tick to stop the Timer, so setting the
      # tick-duration to a high value will make shutting down the actor system
      # take longer.
      tick-duration = 10ms

      # The timer uses a circular wheel of buckets to store the timer tasks.
      # This should be set such that the majority of scheduled timeouts (for high
      # scheduling frequency) will be shorter than one rotation of the wheel
      # (ticks-per-wheel * ticks-duration)
      # THIS MUST BE A POWER OF TWO!
      ticks-per-wheel = 512

      # This setting selects the timer implementation which shall be loaded at
      # system start-up.
      # The class given here must implement the akka.actor.Scheduler interface
      # and offer a public constructor which takes three arguments:
      #  1) com.typesafe.config.Config
      #  2) akka.event.LoggingAdapter
      #  3) java.util.concurrent.ThreadFactory
      implementation = de.frosner.dds.akka.actor.LightArrayRevolverScheduler

      # When shutting down the scheduler, there will typically be a thread which
      # needs to be stopped, and this timeout determines how long to wait for
      # that to happen. In case of timeout the shutdown of the actor system will
      # proceed without running possibly still enqueued tasks.
      shutdown-timeout = 5s
    }

    io {

      # By default the select loops run on dedicated threads, hence using a
      # PinnedDispatcher
      pinned-dispatcher {
        type = "PinnedDispatcher"
        executor = "thread-pool-executor"
        thread-pool-executor.allow-core-pool-timeout = off
      }

      tcp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this TCP module; there is
        # no intrinsic general limit, this setting is meant to enable DoS
        # protection by limiting the number of concurrently connected clients.
        # Also note that this is a "soft" limit; in certain cases the implementation
        # will accept a few connections more or a few less than the number configured
        # here. Must be an integer > 0 or "unlimited".
        max-channels = 256000

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of connection that are accepted in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        batch-accept-limit = 10

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The duration a connection actor waits for a `Register` message from
        # its commander before aborting the connection.
        register-timeout = 5s

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        max-received-message-size = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # on which file IO tasks are scheduled
        file-io-dispatcher = "akka.actor.default-dispatcher"

        # The maximum number of bytes (or "unlimited") to transfer in one batch
        # when using `WriteFile` command which uses `FileChannel.transferTo` to
        # pipe files to a TCP socket. On some OS like Linux `FileChannel.transferTo`
        # may block for a long time when network IO is faster than file IO.
        # Decreasing the value may improve fairness while increasing may improve
        # throughput.
        file-io-transferTo-limit = 512 KiB

        # The number of times to retry the `finishConnect` call after being notified about
        # OP_CONNECT. Retries are needed if the OP_CONNECT notification doesn't imply that
        # `finishConnect` will succeed, which is the case on Android.
        finish-connect-retries = 5
      }

      udp {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }

      udp-connected {

        # The number of selectors to stripe the served channels over; each of
        # these will use one select loop on the selector-dispatcher.
        nr-of-selectors = 1

        # Maximum number of open channels supported by this UDP module Generally
        # UDP does not require a large number of channels, therefore it is
        # recommended to keep this setting low.
        max-channels = 4096

        # The select loop can be used in two modes:
        # - setting "infinite" will select without a timeout, hogging a thread
        # - setting a positive timeout will do a bounded select call,
        #   enabling sharing of a single thread between multiple selectors
        #   (in this case you will have to use a different configuration for the
        #   selector-dispatcher, e.g. using "type=Dispatcher" with size 1)
        # - setting it to zero means polling, i.e. calling selectNow()
        select-timeout = infinite

        # When trying to assign a new connection to a selector and the chosen
        # selector is at full capacity, retry selector choosing and assignment
        # this many times before giving up
        selector-association-retries = 10

        # The maximum number of datagrams that are read in one go,
        # higher numbers decrease latency, lower numbers increase fairness on
        # the worker-dispatcher
        receive-throughput = 3

        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 128 KiB

        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 1000

        # The maximum number of bytes delivered by a `Received` message. Before
        # more data is read from the network the connection actor will try to
        # do other work.
        received-message-size-limit = unlimited

        # Enable fine grained logging of what goes on inside the implementation.
        # Be aware that this may log more than once per message sent to the actors
        # of the tcp implementation.
        trace-logging = off

        # Fully qualified config path which holds the dispatcher configuration
        # to be used for running the select() calls in the selectors
        selector-dispatcher = "akka.io.pinned-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the read/write worker actors
        worker-dispatcher = "akka.actor.default-dispatcher"

        # Fully qualified config path which holds the dispatcher configuration
        # for the selector management actors
        management-dispatcher = "akka.actor.default-dispatcher"
      }

    }


  }

}
